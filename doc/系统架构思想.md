##### 微服务架构设计

###### 核心思想

+ 将单体应用分解为可重用的组件，“组件化”这个词汇应用于web，而插件主要应用于单机的APP、PC小程序等。

###### 解决需求

> 不同的开发团队服务于同一个大型项目，每个开发团队需要获取如下的功能。
>
> 1. 更改他们的数据库架构
> 2. 快速且频繁地将他们的代码发布到生产环境中
> 3. 使用他们选择的编程语言或数据存储等开发工具
> 4. 在计算资源和开发人员生产力之间做出自己的权衡
> 5. 偏好维护/监控其功能

###### 理想的解决方案

> 1. 组件拆分为更小的、独立的服务，每个小团队负责各个部分的研发。
> 2. 处理程序内部的逻辑将依次多次调用数据库，获取呈现页面所需的信息并将其拼接在一起。(处理不同场景下的微服务拼接，可以总结为微服务的派发)
> 3. 应用微服务负责根据不同的用户类别聚合专门服务返回的数据

###### 关键技术

> 1. 计算和存储分离
> 2. 异步处理
> 3. 消息总线（单体应用程序被分解为事件处理程序和事件发射器，就需要一个健壮、高性能和灵活的消息总线，包括Redis、Kafka）
> 4. MVCC多版本高并发控制，API支持旧的API

![image-20220902075600388](https://raw.githubusercontent.com/Lincong-pro/C-Properties/master/img/202209020801858.png)

###### 优点

> 1. 每个微服务可以随心所欲地部署服务，对其他开发团队不会造成影响（自动化测试）
> 2. 自定义拓展和定义服务运行方式和环境（灵活部署）
> 3. 拥有自己特定于其服务的监控、备份和灾难恢复（弹性扩容）

##### 容器

+ 前言

  > 个人对于容器的了解还源于Docker，主要用于解决快速部署线上服务，不需要测试花费太多的精力进行部署，相比而言Docker更像是一个轻量化的虚拟机，即便隔离度没有虚拟机好。Docker允许开发人员获取他们的可执行文件及其依赖项，以及他们想要的任何其他文件，并将它们全部打包成一个文件。

+ 定义

  > 1. 容器实际上一个运行在Linux上的进程
  > 2. 容器具有以下限制
  >    - 容器不允许“看到”所有文件系统，它只能访问其中的指定部分
  >    - 一个容器不允许使用所有的 CPU 或 RAM。
  >    - 容器在如何使用网络方面受到限制。
  > 3. 容器镜像是可执行进程的依赖和配置打包

##### Kubernetes

###### 解决需求

> 1. 动态分配计算资源（充分利用资源）
> 2. 解决单体应用向微服务的过渡

###### Kubernetes分解单体应用

> 1. 预测每个服务需要多少计算资源
> 2. 负载下如何动态分配
> 3. 划分基础设施分区并将它们划分到微服务之间
> 4. 实施资源限制